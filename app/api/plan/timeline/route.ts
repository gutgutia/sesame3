import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { getCurrentProfileId } from "@/lib/auth";

export async function GET(request: NextRequest) {
  try {
    // Get profile from session (using the correct auth system)
    const profileId = await getCurrentProfileId();

    if (!profileId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Get query params
    const { searchParams } = new URL(request.url);
    const filter = searchParams.get("filter") || "all";
    const includeCompleted = searchParams.get("completed") === "true";

    // Fetch tasks with due dates
    const tasks = await prisma.task.findMany({
      where: {
        studentProfileId: profileId,
        dueDate: { not: null },
        ...(includeCompleted ? {} : { status: { not: "completed" } }),
      },
      select: {
        id: true,
        title: true,
        status: true,
        dueDate: true,
        priority: true,
        type: true,
        goalId: true,
      },
      orderBy: { dueDate: "asc" },
      take: 50,
    });
    // Fetch goals with target dates
    const goals = await prisma.goal.findMany({
      where: {
        studentProfileId: profileId,
        targetDate: { not: null },
        ...(includeCompleted ? {} : { status: { not: "completed" } }),
      },
      select: {
        id: true,
        title: true,
        status: true,
        targetDate: true,
        category: true,
      },
      orderBy: { targetDate: "asc" },
      take: 20,
    });
    // Format and group
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    const timelineItems = [
      ...tasks.map(task => ({
        id: task.id,
        type: "task" as const,
        taskType: (task.type || "action") as "milestone" | "action",
        title: task.title,
        description: null,
        dueDate: task.dueDate,
        status: task.status,
        priority: task.priority,
        sourceType: "manual" as const,
        deadlineType: null,
        isHardDeadline: false,
        isAutoGenerated: false,
        goal: task.goalId ? { id: task.goalId, title: "", category: "" } : null,
        school: null,
        program: null,
        parentTask: null,
      })),
      ...goals.map(goal => ({
        id: goal.id,
        type: "goal" as const,
        taskType: "milestone" as const,
        title: goal.title,
        description: null,
        dueDate: goal.targetDate,
        status: goal.status,
        priority: null,
        sourceType: "manual" as const,
        deadlineType: null,
        isHardDeadline: false,
        isAutoGenerated: false,
        goal: null,
        school: null,
        program: null,
        parentTask: null,
      })),
    ];

    // Group by time period
    const grouped = {
      overdue: timelineItems.filter(i => i.dueDate && new Date(i.dueDate) < today),
      today: timelineItems.filter(i => i.dueDate && new Date(i.dueDate).toDateString() === today.toDateString()),
      thisWeek: [] as typeof timelineItems,
      nextWeek: [] as typeof timelineItems,
      thisMonth: [] as typeof timelineItems,
      later: [] as typeof timelineItems,
    };

    // Fill remaining groups
    const endOfWeek = new Date(today);
    endOfWeek.setDate(today.getDate() + (7 - today.getDay()));

    for (const item of timelineItems) {
      if (!item.dueDate) continue;
      const d = new Date(item.dueDate);
      if (d < today || d.toDateString() === today.toDateString()) continue;
      if (d <= endOfWeek) grouped.thisWeek.push(item);
      else grouped.later.push(item);
    }

    return NextResponse.json({
      items: timelineItems,
      grouped,
      total: timelineItems.length,
      filter,
      range: "all",
    });
  } catch (error) {
    console.error("[Timeline] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch timeline", details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}
