import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { createClient } from "@/lib/supabase/server";

// Deadline type mappings for schools
const SCHOOL_DEADLINE_TYPES = {
  early_decision: { field: "deadlineEd", label: "Early Decision" },
  early_decision_2: { field: "deadlineEd2", label: "Early Decision II" },
  early_action: { field: "deadlineEa", label: "Early Action" },
  restrictive_early_action: { field: "deadlineRea", label: "Restrictive Early Action" },
  regular_decision: { field: "deadlineRd", label: "Regular Decision" },
  financial_aid: { field: "deadlineFinancialAid", label: "Financial Aid" },
  commitment: { field: "deadlineCommitment", label: "Enrollment Commitment" },
  notification_ed: { field: "notificationEd", label: "ED Notification" },
  notification_ea: { field: "notificationEa", label: "EA Notification" },
  notification_rd: { field: "notificationRd", label: "RD Notification" },
} as const;

// Deadline type mappings for summer programs
const PROGRAM_DEADLINE_TYPES = {
  application_opens: { field: "applicationOpens", label: "Application Opens" },
  early_deadline: { field: "earlyDeadline", label: "Early Deadline" },
  application_deadline: { field: "applicationDeadline", label: "Application Deadline" },
  notification: { field: "notificationDate", label: "Notification Date" },
  program_start: { field: "startDate", label: "Program Starts" },
  program_end: { field: "endDate", label: "Program Ends" },
} as const;

type SchoolDeadlineType = keyof typeof SCHOOL_DEADLINE_TYPES;
type ProgramDeadlineType = keyof typeof PROGRAM_DEADLINE_TYPES;

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const profile = await prisma.studentProfile.findUnique({
      where: { userId: user.id },
      select: { id: true },
    });

    if (!profile) {
      return NextResponse.json({ error: "Profile not found" }, { status: 404 });
    }

    const body = await request.json();
    const { type, sourceId, deadlines, applicationType } = body as {
      type: "school" | "program";
      sourceId: string;
      deadlines: string[];
      applicationType?: string; // For schools: "ed" | "ea" | "rd" etc.
    };

    if (!type || !sourceId || !deadlines || !Array.isArray(deadlines)) {
      return NextResponse.json(
        { error: "Missing required fields: type, sourceId, deadlines" },
        { status: 400 }
      );
    }

    let goalTitle: string;
    let goalCategory = "application";
    let createdGoal;
    let createdTasks: Array<{ id: string; title: string; dueDate: Date | null }> = [];

    if (type === "school") {
      // Get school details
      const school = await prisma.school.findUnique({
        where: { id: sourceId },
      });

      if (!school) {
        return NextResponse.json({ error: "School not found" }, { status: 404 });
      }

      // Check if a goal already exists for this school
      let existingGoal = await prisma.goal.findFirst({
        where: {
          studentProfileId: profile.id,
          schoolId: sourceId,
          isAutoGenerated: true,
        },
      });

      if (!existingGoal) {
        // Create the application goal
        goalTitle = `Apply to ${school.name}`;
        existingGoal = await prisma.goal.create({
          data: {
            studentProfileId: profile.id,
            title: goalTitle,
            category: goalCategory,
            status: "planning",
            schoolId: sourceId,
            isAutoGenerated: true,
          },
        });
      }

      createdGoal = existingGoal;

      // Create tasks for each selected deadline
      for (const deadlineType of deadlines) {
        const deadlineInfo = SCHOOL_DEADLINE_TYPES[deadlineType as SchoolDeadlineType];
        if (!deadlineInfo) continue;

        const dueDate = school[deadlineInfo.field as keyof typeof school] as Date | null;

        // Check if task already exists
        const existingTask = await prisma.task.findFirst({
          where: {
            studentProfileId: profile.id,
            schoolId: sourceId,
            deadlineType: deadlineType,
          },
        });

        if (!existingTask) {
          const task = await prisma.task.create({
            data: {
              studentProfileId: profile.id,
              goalId: existingGoal.id,
              title: `${school.shortName || school.name} ${deadlineInfo.label}`,
              dueDate,
              deadlineType,
              schoolId: sourceId,
              isAutoGenerated: true,
              isHardDeadline: true,
              status: "pending",
            },
          });

          createdTasks.push({
            id: task.id,
            title: task.title,
            dueDate: task.dueDate,
          });
        }
      }
    } else if (type === "program") {
      // Get program details
      const program = await prisma.summerProgram.findUnique({
        where: { id: sourceId },
      });

      if (!program) {
        return NextResponse.json({ error: "Program not found" }, { status: 404 });
      }

      // Check if a goal already exists for this program
      let existingGoal = await prisma.goal.findFirst({
        where: {
          studentProfileId: profile.id,
          summerProgramId: sourceId,
          isAutoGenerated: true,
        },
      });

      if (!existingGoal) {
        // Create the application goal
        goalTitle = `Apply to ${program.shortName || program.name}`;
        existingGoal = await prisma.goal.create({
          data: {
            studentProfileId: profile.id,
            title: goalTitle,
            category: "research",
            status: "planning",
            summerProgramId: sourceId,
            isAutoGenerated: true,
          },
        });
      }

      createdGoal = existingGoal;

      // Create tasks for each selected deadline
      for (const deadlineType of deadlines) {
        const deadlineInfo = PROGRAM_DEADLINE_TYPES[deadlineType as ProgramDeadlineType];
        if (!deadlineInfo) continue;

        const dueDate = program[deadlineInfo.field as keyof typeof program] as Date | null;

        // Check if task already exists
        const existingTask = await prisma.task.findFirst({
          where: {
            studentProfileId: profile.id,
            summerProgramId: sourceId,
            deadlineType: deadlineType,
          },
        });

        if (!existingTask) {
          const task = await prisma.task.create({
            data: {
              studentProfileId: profile.id,
              goalId: existingGoal.id,
              title: `${program.shortName || program.name} ${deadlineInfo.label}`,
              dueDate,
              deadlineType,
              summerProgramId: sourceId,
              isAutoGenerated: true,
              isHardDeadline: deadlineType !== "notification" && !deadlineType.startsWith("program_"),
              status: "pending",
            },
          });

          createdTasks.push({
            id: task.id,
            title: task.title,
            dueDate: task.dueDate,
          });
        }
      }
    }

    return NextResponse.json({
      success: true,
      goal: createdGoal ? { id: createdGoal.id, title: createdGoal.title } : null,
      tasks: createdTasks,
      message: `Created ${createdTasks.length} deadline${createdTasks.length !== 1 ? "s" : ""} in your plan`,
    });
  } catch (error) {
    console.error("[Import Deadlines] Error:", error);
    return NextResponse.json(
      { error: "Failed to import deadlines" },
      { status: 500 }
    );
  }
}

// GET endpoint to fetch available deadlines for a school/program
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const type = searchParams.get("type");
    const sourceId = searchParams.get("sourceId");

    if (!type || !sourceId) {
      return NextResponse.json(
        { error: "Missing required params: type, sourceId" },
        { status: 400 }
      );
    }

    const profile = await prisma.studentProfile.findUnique({
      where: { userId: user.id },
      select: { id: true },
    });

    if (!profile) {
      return NextResponse.json({ error: "Profile not found" }, { status: 404 });
    }

    if (type === "school") {
      const school = await prisma.school.findUnique({
        where: { id: sourceId },
      });

      if (!school) {
        return NextResponse.json({ error: "School not found" }, { status: 404 });
      }

      // Get existing tasks for this school
      const existingTasks = await prisma.task.findMany({
        where: {
          studentProfileId: profile.id,
          schoolId: sourceId,
        },
        select: { deadlineType: true },
      });

      const existingTypes = new Set(existingTasks.map(t => t.deadlineType));

      // Build available deadlines
      const deadlines = Object.entries(SCHOOL_DEADLINE_TYPES).map(([key, info]) => {
        const date = school[info.field as keyof typeof school] as Date | null;
        return {
          type: key,
          label: info.label,
          date,
          alreadyAdded: existingTypes.has(key),
        };
      }).filter(d => d.date !== null); // Only show deadlines that have dates

      return NextResponse.json({
        name: school.name,
        shortName: school.shortName,
        deadlines,
      });
    } else if (type === "program") {
      const program = await prisma.summerProgram.findUnique({
        where: { id: sourceId },
      });

      if (!program) {
        return NextResponse.json({ error: "Program not found" }, { status: 404 });
      }

      // Get existing tasks for this program
      const existingTasks = await prisma.task.findMany({
        where: {
          studentProfileId: profile.id,
          summerProgramId: sourceId,
        },
        select: { deadlineType: true },
      });

      const existingTypes = new Set(existingTasks.map(t => t.deadlineType));

      // Build available deadlines
      const deadlines = Object.entries(PROGRAM_DEADLINE_TYPES).map(([key, info]) => {
        const date = program[info.field as keyof typeof program] as Date | null;
        return {
          type: key,
          label: info.label,
          date,
          alreadyAdded: existingTypes.has(key),
        };
      }).filter(d => d.date !== null);

      return NextResponse.json({
        name: program.name,
        shortName: program.shortName,
        deadlines,
      });
    }

    return NextResponse.json({ error: "Invalid type" }, { status: 400 });
  } catch (error) {
    console.error("[Get Deadlines] Error:", error);
    return NextResponse.json(
      { error: "Failed to fetch deadlines" },
      { status: 500 }
    );
  }
}
